#!/usr/bin/env python
"""
HDF5 to PVAccess NTNDArray Streamer

Stream HDF5 dataset frames to a PVAccess NTNDArray PV with configurable framerate.
"""

import h5py
import numpy as np
import pvaccess as pva
import time
import argparse
from pathlib import Path
from threading import Thread
from queue import Queue


class AdImageUtility:
    """
    Utility class for manipulating Area Detector images.
    """
    
    NTNDA_DATA_FIELD_KEY_MAP = {
        np.dtype('uint8')   : 'ubyteValue',
        np.dtype('int8')    : 'byteValue',
        np.dtype('uint16')  : 'ushortValue',
        np.dtype('int16')   : 'shortValue',
        np.dtype('uint32')  : 'uintValue',
        np.dtype('int32')   : 'intValue',
        np.dtype('uint64')  : 'ulongValue',
        np.dtype('int64')   : 'longValue',
        np.dtype('float32') : 'floatValue',
        np.dtype('float64') : 'doubleValue'
    }

    PVA_DATA_TYPE_MAP = {
        np.dtype('uint8')   : pva.UBYTE,
        np.dtype('int8')    : pva.BYTE,
        np.dtype('uint16')  : pva.USHORT,
        np.dtype('int16')   : pva.SHORT,
        np.dtype('uint32')  : pva.UINT,
        np.dtype('int32')   : pva.INT,
        np.dtype('uint64')  : pva.ULONG,
        np.dtype('int64')   : pva.LONG,
        np.dtype('float32') : pva.FLOAT,
        np.dtype('float64') : pva.DOUBLE
    }

    @classmethod
    def generateNtNdArray2D(cls, imageId, imageData, nx=None, ny=None, dtype=None, 
                           compressorName=None, extraFieldsPvObject=None):
        """Generate NTNDA for a mono image."""
        if extraFieldsPvObject is None:
            ntNdArray = pva.NtNdArray()
        else:
            ntNdArray = pva.NtNdArray(extraFieldsPvObject.getStructureDict())

        dataFieldKey = cls.NTNDA_DATA_FIELD_KEY_MAP.get(imageData.dtype)
        data = imageData.flatten()
        
        if not compressorName:
            pvaDataType = cls.PVA_DATA_TYPE_MAP.get(imageData.dtype)
            ny, nx = imageData.shape
            size = nx * ny * data.itemsize
            ntNdArray['compressedSize'] = size
            ntNdArray['uncompressedSize'] = size
        else:
            dtype = np.dtype(dtype)
            pvaDataType = cls.PVA_DATA_TYPE_MAP.get(dtype)
            codec = pva.PvCodec(compressorName, pva.PvInt(int(pvaDataType)))
            ntNdArray['codec'] = codec
            size = nx * ny * dtype.itemsize
            ntNdArray['uncompressedSize'] = size
            ntNdArray['compressedSize'] = len(data)

        ntNdArray['uniqueId'] = int(imageId)
        dims = [pva.PvDimension(nx, 0, nx, 1, False),
                pva.PvDimension(ny, 0, ny, 1, False)]
        ntNdArray['dimension'] = dims
        ts = pva.PvTimeStamp(time.time())
        ntNdArray['timeStamp'] = ts
        ntNdArray['dataTimeStamp'] = ts
        ntNdArray['descriptor'] = 'Image generated by PvaPy'

        ntNdArray['value'] = {dataFieldKey: data}
        attrs = [pva.NtAttribute('ColorMode', pva.PvInt(0))]
        ntNdArray['attribute'] = attrs
        
        if extraFieldsPvObject is not None:
            ntNdArray.set(extraFieldsPvObject)
            
        return ntNdArray

    @classmethod
    def replaceNtNdArrayImage2D(cls, ntNdArray, imageId, image, extraFieldsPvObject=None):
        """
        Replace image data in an existing NTNDArray.
        Assumes new image is of the same data type as the old one.
        """
        dataFieldKey = cls.NTNDA_DATA_FIELD_KEY_MAP.get(image.dtype)
        pvaDataType = cls.PVA_DATA_TYPE_MAP.get(image.dtype)
        data = image.flatten()
        ntNdArray['uniqueId'] = int(imageId)

        ny, nx = image.shape
        dims = ntNdArray['dimension']
        
        if dims[0]['size'] != nx or dims[1]['size'] != ny:
            dims = [pva.PvDimension(nx, 0, nx, 1, False),
                    pva.PvDimension(ny, 0, ny, 1, False)]
            ntNdArray['dimension'] = dims
            size = nx * ny * data.itemsize
            ntNdArray['compressedSize'] = size
            ntNdArray['uncompressedSize'] = size
            
        ts = pva.PvTimeStamp(time.time())
        ntNdArray['timeStamp'] = ts
        ntNdArray['dataTimeStamp'] = ts

        u = pva.PvObject({dataFieldKey: [pvaDataType]}, {dataFieldKey: data})
        ntNdArray.setUnion(u)
        
        if extraFieldsPvObject is not None:
            ntNdArray.set(extraFieldsPvObject)
            
        return ntNdArray


class HDF5StreamToPV:
    """
    Stream HDF5 dataset frames to a PVAccess NTNDArray PV with frame prefetching.
    """
    
    def __init__(self, pv_name, hdf5_file, dataset_path, framerate=10, 
                 loop=False, start_frame=0, end_frame=None, prefetch_size=5):
        """
        Initialize HDF5 to PV streamer.
        
        Parameters:
        ----------
        pv_name : str
            Name of the NTNDArray PV to publish to
        hdf5_file : str or Path
            Path to the HDF5 file
        dataset_path : str
            Path to the dataset within the HDF5 file (e.g., '/entry/data/data')
        framerate : float
            Frames per second to stream (default: 10)
        loop : bool
            If True, loop the dataset continuously (default: False)
        start_frame : int
            Starting frame index (default: 0)
        end_frame : int or None
            Ending frame index, None for end of dataset (default: None)
        prefetch_size : int
            Number of frames to prefetch in buffer (default: 5)
        """
        self.pv_name = pv_name
        self.hdf5_file = Path(hdf5_file)
        self.dataset_path = dataset_path
        self.framerate = framerate
        self.loop = loop
        self.start_frame = start_frame
        self.end_frame = end_frame
        self.prefetch_size = prefetch_size
        
        self.server = None
        self.nt = None
        self.is_streaming = False
        
        # Validate HDF5 file
        if not self.hdf5_file.exists():
            raise FileNotFoundError(f"HDF5 file not found: {self.hdf5_file}")
        
        # Initialize PV server
        self._initialize_server()
    
    def _initialize_server(self):
        """Initialize the PVA server with a dummy NTNDArray."""
        dummy = np.zeros((1, 1), dtype=np.uint8)
        self.nt = AdImageUtility.generateNtNdArray2D(0, dummy)
        self.server = pva.PvaServer()
        self.server.addRecord(self.pv_name, self.nt)
        print(f"PV server initialized: {self.pv_name}")
    
    def _frame_reader(self, h5f, dataset, frame_queue, start_frame, end_frame):
        """Background thread to read frames from HDF5."""
        try:
            while self.is_streaming:
                for frame_idx in range(start_frame, end_frame):
                    if not self.is_streaming:
                        break
                    frame = dataset[frame_idx].copy()  # Copy to avoid HDF5 threading issues
                    frame_queue.put((frame_idx, frame))
                
                if not self.loop:
                    break
                    
        except Exception as e:
            print(f"Error in frame reader: {e}")
        finally:
            frame_queue.put(None)  # Signal end of stream
    
    def stream(self):
        """
        Start streaming the HDF5 dataset to the PV.
        """
        self.is_streaming = True
        frame_delay = 1.0 / self.framerate
        
        with h5py.File(self.hdf5_file, 'r') as h5f:
            if self.dataset_path not in h5f:
                raise ValueError(f"Dataset '{self.dataset_path}' not found in {self.hdf5_file}")
            
            dataset = h5f[self.dataset_path]
            total_frames = dataset.shape[0]
            end_frame = self.end_frame if self.end_frame is not None else total_frames
            
            print(f"Dataset shape: {dataset.shape}")
            print(f"Dataset dtype: {dataset.dtype}")
            print(f"Streaming frames {self.start_frame} to {end_frame-1} at {self.framerate} fps")
            print(f"Frame delay: {frame_delay:.4f} seconds")
            print(f"Prefetch buffer size: {self.prefetch_size} frames")
            print("Press Ctrl+C to stop\n")
            
            # Create frame queue and start reader thread
            frame_queue = Queue(maxsize=self.prefetch_size)
            reader_thread = Thread(
                target=self._frame_reader,
                args=(h5f, dataset, frame_queue, self.start_frame, end_frame),
                daemon=True
            )
            reader_thread.start()
            
            uid = 1
            lag_count = 0
            
            try:
                while self.is_streaming:
                    start_time = time.time()
                    
                    # Get next frame from queue
                    frame_data = frame_queue.get()
                    if frame_data is None:
                        break
                    
                    frame_idx, frame = frame_data
                    
                    # Ensure 2D array
                    if frame.ndim != 2:
                        print(f"Warning: Frame {frame_idx} is not 2D (shape: {frame.shape}), skipping")
                        continue
                    
                    # Update NTNDArray
                    AdImageUtility.replaceNtNdArrayImage2D(self.nt, uid, frame)
                    self.server.update(self.nt)
                    
                    # Print progress (less frequently to reduce overhead)
                    if uid % 100 == 0 or uid == 1:
                        queue_size = frame_queue.qsize()
                        print(f"Frame {frame_idx}/{end_frame-1} (UID: {uid}) [Buffer: {queue_size}/{self.prefetch_size}]")
                    
                    uid += 1
                    
                    # Maintain framerate
                    elapsed = time.time() - start_time
                    sleep_time = frame_delay - elapsed
                    if sleep_time > 0:
                        time.sleep(sleep_time)
                    else:
                        lag_count += 1
                        if lag_count % 100 == 1:  # Warn less frequently
                            print(f"Warning: Processing slower than framerate (lag: {-sleep_time:.3f}s)")
                    
            except KeyboardInterrupt:
                print("\n\nStreaming stopped by user")
            finally:
                self.is_streaming = False
                reader_thread.join(timeout=2)
                print(f"Streaming completed. Total frames streamed: {uid-1}")
                if lag_count > 0:
                    print(f"Lag warnings: {lag_count} frames")
    
    def stop(self):
        """Stop the streaming."""
        self.is_streaming = False
    
    def set_framerate(self, framerate):
        """Update the framerate during streaming."""
        self.framerate = framerate
        print(f"Framerate updated to {framerate} fps")


def main():
    parser = argparse.ArgumentParser(
        description='Stream HDF5 dataset to PVAccess NTNDArray PV',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Stream at 10 fps (default)
  python datastream.py 32ID:HDF5:Image data.h5 /exchange/data

  # Stream at 30 fps with looping
  python datastream.py 32ID:HDF5:Image data.h5 /exchange/data -f 30 --loop

  # Stream specific frame range at 20 fps
  python datastream.py 32ID:HDF5:Image data.h5 /exchange/data -f 20 -s 100 -e 500

  # Increase prefetch buffer for smoother streaming
  python datastream.py 32ID:HDF5:Image data.h5 /exchange/data -f 30 -p 10
        """
    )
    
    parser.add_argument('pv_name', type=str,
                        help='PVAccess NTNDArray PV name (e.g., 32ID:HDF5:Image)')
    parser.add_argument('hdf5_file', type=str,
                        help='Path to HDF5 file')
    parser.add_argument('dataset_path', type=str,
                        help='Path to dataset in HDF5 file (e.g., /exchange/data)')
    parser.add_argument('-f', '--framerate', type=float, default=10,
                        help='Frames per second (default: 10)')
    parser.add_argument('-l', '--loop', action='store_true',
                        help='Loop the dataset continuously')
    parser.add_argument('-s', '--start-frame', type=int, default=0,
                        help='Starting frame index (default: 0)')
    parser.add_argument('-e', '--end-frame', type=int, default=None,
                        help='Ending frame index (default: end of dataset)')
    parser.add_argument('-p', '--prefetch-size', type=int, default=5,
                        help='Number of frames to prefetch (default: 5)')
    
    args = parser.parse_args()
    
    print("="*60)
    print("HDF5 to PVAccess NTNDArray Streamer")
    print("="*60)
    
    # Create and start streamer
    streamer = HDF5StreamToPV(
        pv_name=args.pv_name,
        hdf5_file=args.hdf5_file,
        dataset_path=args.dataset_path,
        framerate=args.framerate,
        loop=args.loop,
        start_frame=args.start_frame,
        end_frame=args.end_frame,
        prefetch_size=args.prefetch_size
    )
    
    streamer.stream()


if __name__ == "__main__":
    main()
